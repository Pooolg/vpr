# Лабораторная работа #6.2 - Протоколы Telnet и SSH

## Материалы
- [Lab-6.2 - Протоколы Telnet и SSH.docx](./Lab-6.2%20-%20%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB%D1%8B%20Telnet%20%D0%B8%20SSH.docx)

## Работа

Нам потребуется 2 ВМ. Я буду использовать две [Ubuntu Server](https://ubuntu.com/download/server#downloads)


### Настроим сеть NAT

Для начала создадим общую сеть NAT для виртуальных машин.

Откройте **Файл** -> **Инструменты** -> **Менеджер сетей**

![Screenshot_20230504_193557](https://user-images.githubusercontent.com/76239707/236268229-2c33b00f-64cc-4dc7-9a72-25b011854a9f.png)

Выберите **Сети NAT** и нажмите **Создать**. Должно получится примерно как на скриншоте:

![Screenshot_20230504_193718](https://user-images.githubusercontent.com/76239707/236268652-ab9b7cd1-0879-43e3-ab19-1ae709efd3e8.png)

Далее для каждой ВМ выполните откройте **Настройки** -> **Сеть** -> Выберите именно **Сеть NAT** для первого адаптера (не путать с просто **NAT**). Имя только что созданной сети. Настраиваемая машина в это время должна быть отключена

![Screenshot_20230504_193826](https://user-images.githubusercontent.com/76239707/236269064-6048cf53-ef83-481d-bf65-08b453aa44b4.png)

Поздравляем, сеть настроена!

### ВМ 1

Имеем:

![Screenshot_20230504_192926](https://user-images.githubusercontent.com/76239707/236266629-ee5bacd4-f773-4855-9ee8-4136d3b1ae74.png)

Установим `telnetd` - демон, который будет являться сервером telnet

```bash
sudo apt update && sudo apt-get install telnetd

```

Также установим `openssh-server` (обычно предустановлен)
```bash
sudo apt install openssh-server
```


### ВМ 2

Имеем:

![Screenshot_20230504_192959](https://user-images.githubusercontent.com/76239707/236266798-3c389e7c-93d9-489b-b6f1-232de8563da7.png)

#### Telnet

Подключимся к ВМ1 по технологии `telnet`, для этого выполним:
```bash
telnet 10.0.2.4
```
Где `10.0.2.4` - ip адрес ВМ1

Вводим логин/пароль и вот результат:

![Screenshot_20230504_195126](https://user-images.githubusercontent.com/76239707/236272026-cc2d45cd-c7ae-4b52-be96-244305fe5efd.png)

Чтобы оборвать соединение, напишем в консоль:
```bash
exit
```

Справка:***Telnet** является старым протоколом, который был создан в 1969 году. Он работает на основе текстовых команд и не обеспечивает шифрование данных, как **SSH**, хотя интуитивно они выполняют одну и ту же функцию.*


#### SSH

Теперь попробуем подключиться по **SSH**, для этого выполним:

```bash
ssh 10.0.2.4
```
Мы сразу видим, что клиент ssh нас предупреждает о том, что мы подключаемся к этому компьютеру впервые. Подстверждаем отпечаток ответив `yes`. Вводим данные для авторизации и вуаля:

![Screenshot_20230504_200304](https://user-images.githubusercontent.com/76239707/236274895-f2e78a47-aabb-4411-8f8c-af145a2d3ee4.png)

Выходим, прописав `exit` в консоль


#### SSH - Аутентификация по RSA ключу

Мы попробовали подключиться по **SSH**, используя пароль. Однако, **SSH** предоставляет куда более серьезные возможности идентификации, например, RSA-ключ. Зачем это нужно? Во-первых, Ваш пароль можно сбрутить. Если вы думаете, что ваш сервер никому не нужен, то вы ошибаетесь: китайские брутфорс-машины всегда рады халявному рак-боту. Во-вторых, не всегда хочется запоминать пароли, а иногда хочется просто подключиться к серверу без головной боли в один клик. Давайте попробуем настроить такую аутентификацию.

Для начала сгенерируем RSA ключ:
```bash
ssh-keygen -t rsa

```

![image](https://user-images.githubusercontent.com/76239707/236279340-f4bb8a33-07b7-45ab-ade2-539565cb62dc.png)

Прожимаем везде *enter*. Ключ был сохранен в домашней директории, путь до файла `~/.ssh/id_rsa.pub`

Затем отправим этот ключ на сервеер, выполнив:

```bash
ssh-copy-id -i ~/.ssh/id_rsa.pub jkearnsl@10.0.2.4
```

Вводим пароль и видим, что ключ успешно установлен:

![Screenshot_20230504_202301](https://user-images.githubusercontent.com/76239707/236281133-f601bb32-bbd2-4168-98c0-8881e9a5f0e1.png)

Теперь попробуем подключиться к ВМ1. Мы видим, что ввод ключа не требуется:
![Screenshot_20230504_202449](https://user-images.githubusercontent.com/76239707/236281626-fd8f2277-2299-4be9-b810-d17f691f1343.png)

Разорвем соединение `exit`

Мы успешно установили rsa ключ.

#### Отправка файлов по SSH

Утилита `scp` умеет копировать файлы из сервера к клиенту и обратно. Программа использует протокол **SSH** и имеет следующий синтаксис:

```bash
scp file.txt пользователь@ip_адрес_сервера:~
```
Эта команда скопирует локальный `file.txt` на удаленную машину `пользователь@ip_адрес_сервера` в `~` - т.е в домашнюю папку пользователя `пользователь`.

Давайте попробуем выполнить. Для этого создадим файл `file.txt` c произвольным содержимым:

```bash
echo "supa text" >> file.txt
```

И отправим этот файл на ВМ1 в домашнюю директорию `jkearnsl`:
```bash
scp file.txt jkearnsl@10.0.2.4:~
```
Файл отправлен:
![Screenshot_20230504_204330](https://user-images.githubusercontent.com/76239707/236285741-a626a510-731d-42a8-b2c1-e9d85c178b6c.png)

#### Смена порта SSH

Вернемся к ВМ1

Для редактирования конфигурации SSH сервера, перейдем к `/etc/ssh/sshd_config` и отредактируем строку `#Port 22` на `Port 42` например:

```bash
sudo nano /etc/ssh/sshd_config
```
Сохраняем `Ctrl + o`, *enter*, `Ctrl + x`
![Screenshot_20230504_204957](https://user-images.githubusercontent.com/76239707/236287234-72f607c8-f296-4c88-a9cc-7536d2c8a329.png)

Перезапустим службу **sshd** для приминения изменений:

```bash
sudo systemctl restart sshd
```

Заодно можем включить автозагрузку (если не включена) процесса службы **sshd** для автостарта после перезагрузки командой:
```bash
sudo systemctl enable sshd
```

Попытаемся подключиться с ВМ2 к ВМ1, используя новый порт **42**, используя флаг `-p`:

```bash
ssh 10.0.2.4 -p 42
```
Соединение успешно установлено.

### Дополнительные моменты

Нас просят установить на ВМ1 `net-tools` и выполнить `netstat -a | grep telnet` 

![image](https://user-images.githubusercontent.com/76239707/236290758-6e46fdee-86d8-4270-ad06-6e6e435dd759.png)

Вопрос: *Объясните значения, обведённые синей рамкой.*

Ответ: Из-за того, как работает TCP/IP, соединения не могут быть немедленно закрыты. Пакеты могут поступать не по порядку или быть повторно переданы после закрытия соединения.

- **LISTEN** Сокет прослушивает входящие соединения.
- **ESTABLISHED** Сокет имеет установленное соединение.
- **TIME_WAIT** Соединение уже было закрыто одной из сторон, но еще не было полностью закрыто на другой стороне.

При **TIME_WAIT** сокет все еще связан с локальным и удаленным IP-адресами и портами, которые использовались для установки соединения, поэтому мы наблюдаем порт **60838**.

### Контрольные вопросы
1. В чём разница между telnet и SSH?

***Telnet** является старым протоколом, который был создан в 1969 году. Он работает на основе текстовых команд и не обеспечивает шифрование данных, как **SSH**, хотя интуитивно они выполняют одну и ту же функцию.*

2. Что такое порт?

***Порт** - это номер, который используется для определения, какое приложение или служба должны получать трафик данных, проходящий через сетевое устройство. Отслеживается ОС*

3. Какие порты используют по умолчанию telnet и SSH?

*По умолчанию **Telnet** использует порт **23** для соединения, а **SSH** использует порт **22**.*

4. Какой командой в Linux можно проверить готова ли сетевая служба принимать соединения?

`sudo netstat -a | grep telnet` - *на примере **telnet***

5. Какие способы аутентификации поддерживаются в SSH? В чём между ними разница? 

Вообще я знаю 4ре способа, но нас ознакомили с 2мя:

- Парольная аутентификация
- Аутентификация с использованием открытых ключей (RSA, DSA) 

Разница между ними в том, что в первом случае нам требуется вводить пару логин и пароль при каждом подключении, а во втором нам этого делать не нужно

*Авторство: **Бояршинов Н.О***
